var documenterSearchIndex = {"docs":
[{"location":"functions/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"using PortfolioAnalytics\nusing Dates\nusing TSFrames\n\ndates = Date(2020, 12, 31):Month(1):Date(2021, 12, 31)\nTSLA = [235.22,264.51,225.16,222.64,236.48,208.40,226.56,229.06,245.24,258.49,371.33,381.58,352.26]\nNFLX = [540.73,532.39,538.85,521.66,513.47,502.81,528.21,517.57,569.19,610.34,690.31,641.90,602.44]\nMSFT = [222.42,231.96,232.38,235.77,252.18,249.68,270.90,284.91,301.88,281.92,331.62,330.59,336.32]\n\nprices_ts = TSFrame([TSLA NFLX MSFT], dates, colnames=[:TSLA, :NFLX, :MSFT])\n\n13×3 TSFrame with Date Index\n Index       TSLA     NFLX     MSFT    \n Date        Float64  Float64  Float64 \n───────────────────────────────────────\n 2020-12-31   235.22   540.73   222.42 \n 2021-01-31   264.51   532.39   231.96 \n 2021-02-28   225.16   538.85   232.38 \n 2021-03-31   222.64   521.66   235.77 \n 2021-04-30   236.48   513.47   252.18 \n 2021-05-31   208.4    502.81   249.68 \n 2021-06-30   226.56   528.21   270.9  \n 2021-07-31   229.06   517.57   284.91 \n 2021-08-31   245.24   569.19   301.88 \n 2021-09-30   258.49   610.34   281.92 \n 2021-10-31   371.33   690.31   331.62\n 2021-11-30   381.58   641.9    330.59\n 2021-12-31   352.26   602.44   336.32\n\nweights = [0.4, 0.4, 0.2]\n3-element Vector{Float64}:\n 0.4\n 0.4\n 0.2","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"asset_return","category":"page"},{"location":"functions/#PortfolioAnalytics.asset_return","page":"Functions","title":"PortfolioAnalytics.asset_return","text":"asset_return(price::TSFrame, period::Int=1; method::String=\"simple\")\n\nCalculates returns form asset prices.\n\nArguments:\n\nprice::TSFrame: column(s) of TSFrame object of asset prices\nperiod::Int=1: return period\nmethod::String=\"simple\": return method, available methods; \"simple\" and \"log\"\n\nExample\n\njulia> returns = asset_return(prices_ts)\n12×3 TSFrame with Date Index\n Index       TSLA        NFLX        MSFT        \n Date        Float64?    Float64?    Float64?    \n─────────────────────────────────────────────────\n 2021-01-31   0.124522   -0.0154236   0.0428918\n 2021-02-28  -0.148766    0.012134    0.00181066\n 2021-03-31  -0.011192   -0.0319013   0.0145882\n 2021-04-30   0.0621631  -0.0156999   0.0696017\n 2021-05-31  -0.118742   -0.0207607  -0.00991355\n 2021-06-30   0.0871401   0.0505161   0.0849888\n 2021-07-31   0.0110346  -0.0201435   0.0517165\n 2021-08-31   0.0706365   0.0997353   0.0595627\n 2021-09-30   0.0540287   0.0722957  -0.066119\n 2021-10-31   0.436535    0.131025    0.176291\n 2021-11-30   0.0276035  -0.0701279  -0.00310596\n 2021-12-31  -0.0768384  -0.0614737   0.0173326\n\n\n julia> log_returns = asset_return(prices_ts, method = \"log\")\n12×3 TSFrame with Date Index\n Index       TSLA        NFLX        MSFT        \n Date        Float64?    Float64?    Float64?    \n─────────────────────────────────────────────────\n 2021-01-31   0.117358   -0.0155438   0.0419975\n 2021-02-28  -0.161068    0.0120609   0.00180902\n 2021-03-31  -0.0112551  -0.0324212   0.0144828\n 2021-04-30   0.0603075  -0.0158244   0.0672864\n 2021-05-31  -0.126404   -0.0209792  -0.00996302\n 2021-06-30   0.0835505   0.0492816   0.0815697\n 2021-07-31   0.0109742  -0.0203492   0.0504236\n 2021-08-31   0.0682533   0.0950695   0.0578562\n 2021-09-30   0.0526197   0.0698019  -0.0684062\n 2021-10-31   0.362234    0.123125    0.162366\n 2021-11-30   0.0272294  -0.0727082  -0.0031108\n 2021-12-31  -0.079951   -0.0634445   0.0171842\n\nNotes:\n\nmissing resulting from the function is automatically removed\n\n\n\n\n\n","category":"function"},{"location":"functions/","page":"Functions","title":"Functions","text":"portfolio_return","category":"page"},{"location":"functions/#PortfolioAnalytics.portfolio_return","page":"Functions","title":"PortfolioAnalytics.portfolio_return","text":"portfolio_return(price::TSFrame, weights::Vector{<:Number}; period::Int=1, method::String=\"simple\", colname::String=\"PORT\")\n\nCalculates portfolio return from asset prices and given weights.\n\nArguments:\n\nprice::TSFrame: column(s) of TSFrame object of asset prices\nweights::Vector{<:Number}: weights of assets\nperiod::Int=1: return period\nmethod::String=\"simple\": return method, available methods; \"simple\" and \"log\"\ncolname::String=\"PORT\": name of the column of portfolio return\n\nExample\n\njulia> preturns = portfolio_return(prices_ts, weights)\n12×1 TSFrame with Date Index\n Index       PORT        \n Date        Float64?    \n─────────────────────────\n 2021-01-31   0.0522176\n 2021-02-28  -0.0542905\n 2021-03-31  -0.0143197\n 2021-04-30   0.0325056\n 2021-05-31  -0.0577836\n 2021-06-30   0.0720602\n 2021-07-31   0.00669974\n 2021-08-31   0.0800613\n 2021-09-30   0.037306\n 2021-10-31   0.262282\n 2021-11-30  -0.017631\n 2021-12-31  -0.0518583\n\n\n julia> log_preturns = portfolio_return(prices_ts, weights, method = \"log\")\n 12×1 TSFrame with Date Index\n  Index       PORT        \n  Date        Float64?    \n ─────────────────────────\n  2021-01-31   0.0491251\n  2021-02-28  -0.0592409\n  2021-03-31  -0.014574\n  2021-04-30   0.0312505\n  2021-05-31  -0.060946\n  2021-06-30   0.0694468\n  2021-07-31   0.00633473\n  2021-08-31   0.0769004\n  2021-09-30   0.0352874\n  2021-10-31   0.226617\n  2021-11-30  -0.0188137\n  2021-12-31  -0.0539213\n\nNotes:\n\nmissing resulting from the function is automatically removed.\n\n\n\n\n\n","category":"function"},{"location":"functions/","page":"Functions","title":"Functions","text":"julia> all_returns = TSFrames.join(returns, preturns)\n12×4 TSFrame with Date Index\n Index       TSLA        NFLX        MSFT         PORT        \n Date        Float64?    Float64?    Float64?     Float64?    \n──────────────────────────────────────────────────────────────\n 2021-01-31   0.124522   -0.0154236   0.0428918    0.0522176\n 2021-02-28  -0.148766    0.012134    0.00181066  -0.0542905\n 2021-03-31  -0.011192   -0.0319013   0.0145882   -0.0143197\n 2021-04-30   0.0621631  -0.0156999   0.0696017    0.0325056\n 2021-05-31  -0.118742   -0.0207607  -0.00991355  -0.0577836\n 2021-06-30   0.0871401   0.0505161   0.0849888    0.0720602\n 2021-07-31   0.0110346  -0.0201435   0.0517165    0.00669974\n 2021-08-31   0.0706365   0.0997353   0.0595627    0.0800613\n 2021-09-30   0.0540287   0.0722957  -0.066119     0.037306\n 2021-10-31   0.436535    0.131025    0.176291     0.262282\n 2021-11-30   0.0276035  -0.0701279  -0.00310596  -0.017631\n 2021-12-31  -0.0768384  -0.0614737   0.0173326   -0.0518583","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"sharpe","category":"page"},{"location":"functions/#PortfolioAnalytics.sharpe","page":"Functions","title":"PortfolioAnalytics.sharpe","text":"sharpe(R::TSFrame, Rf::Number=0)\n\nCalculates Sharpe Ratio from asset returns. Output is a NamedArray.\n\nArguments:\n\nR::TSFrame: column(s) of TSFrame object of asset returns\nRf::Number=0: Risk-free rate\n\nExample\n\njulia> sharpe = sharpe(returns)\n4-element Named Vector{Float64}\nSharpe Ratio (Rf=0)  │\n─────────────────────┼─────────\nTSLA                 │ 0.288602\nNFLX                 │ 0.170242\nMSFT                 │ 0.606824\n\n\n\n\n\n","category":"function"},{"location":"functions/","page":"Functions","title":"Functions","text":"mean_return","category":"page"},{"location":"functions/#PortfolioAnalytics.mean_return","page":"Functions","title":"PortfolioAnalytics.mean_return","text":"mean_return(R::TSFrame; geometric::Bool=true)\n\nCalculates the mean return from asset returns. Output is a NamedArray.\n\nArguments:\n\nR::TSFrame: column(s) of TSFrame object of asset returns\ngeometric::Bool=true: if true, calculates geometric mean\n\nExample\n\njulia> mean_return(returns)\n4-element Named Vector{Float64}\nμ    │\n─────┼───────────\nTSLA │  0.0342267\nNFLX │ 0.00904634\nMSFT │  0.0350585\n\n\njulia> mean_return(returns, geometric=false)\n4-element Named Vector{Float64}\nμ    │\n─────┼──────────\nTSLA │ 0.0431772\nNFLX │  0.010848\nMSFT │ 0.0366371\n\n\n\n\n\n","category":"function"},{"location":"functions/","page":"Functions","title":"Functions","text":"using NamedArrays# hide\nreturns = [0.0431772, 0.010848, 0.0366371] # hide\ntickers = [\"TSLA\", \"NFLX\", \"MSFT\"] # hide\nmreturn = NamedArray(returns, tickers)# hide\n\nusing Plots\n# plotting mean return of stocks and portfolio\nbar(names(mreturn), mreturn, labels = false)","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"stddev","category":"page"},{"location":"functions/#PortfolioAnalytics.stddev","page":"Functions","title":"PortfolioAnalytics.stddev","text":"stddev(R::TSFrame)\n\nCalculates the standard deviation of asset returns. Output is a NamedArray.\n\nExample\n\njulia> stddev(returns)\n4-element Named Vector{Float64}\nσ    │\n─────┼──────────\nTSLA │  0.149608\nNFLX │ 0.0637211\nMSFT │ 0.0603753\n\n\n\n\n\n","category":"function"},{"location":"functions/","page":"Functions","title":"Functions","text":"moments","category":"page"},{"location":"functions/#PortfolioAnalytics.moments","page":"Functions","title":"PortfolioAnalytics.moments","text":"moments(R::TSFrame)\n\nCalculates the (statistical) moments of asset returns. Output is a NamedArray.\n\nExample\n\njulia> pmoments = moments(returns)\n4×4 Named Matrix{Float64}\nTickers ╲ Moments │      Mean        Std   Skewness   Kurtosis\n──────────────────┼───────────────────────────────────────────\nTSLA              │ 0.0431772   0.149608    1.36882    2.19682\nNFLX              │  0.010848  0.0637211   0.604374  -0.808401\nMSFT              │ 0.0366371  0.0603753   0.681468   0.790701\n\nOutput:\n\nNamedArray; rows: tickers, columns: moments\n\nNotes:\n\nKurtosis: excess kurtosis\n\n\n\n\n\n","category":"function"},{"location":"functions/","page":"Functions","title":"Functions","text":"value_at_risk","category":"page"},{"location":"functions/#PortfolioAnalytics.value_at_risk","page":"Functions","title":"PortfolioAnalytics.value_at_risk","text":"value_at_risk(R::TSFrame, p::Number=0.95; method::String=\"historical\")\n\nCalculates Value-at-Risk(VaR) from asset returns. Output is a NamedArray.\n\nArguments:\n\nR::TSFrame: column(s) of TSFrame object of asset returns\np::Number=0.95: confidence level\nmethod::String=\"historical\": method of VaR calculation, available methods; \"historical\" and \"parametric\"\n\nExample\n\njulia> var_historical = value_at_risk(returns)\n4-element Named Vector{Float64}\n95% historical VaR  │\n────────────────────┼───────────\nTSLA                │  -0.132252\nNFLX                │ -0.0653681\nMSFT                │  -0.035206\n\njulia> var_parametric = value_at_risk(returns, 0.90, method = \"parametric\")\n4-element Named Vector{Float64}\n90% parametric VaR  │\n────────────────────┼───────────\nTSLA                │  -0.148553\nNFLX                │ -0.0708139\nMSFT                │ -0.0407369\n\n\n\n\n\n","category":"function"},{"location":"functions/","page":"Functions","title":"Functions","text":"es","category":"page"},{"location":"functions/#PortfolioAnalytics.es","page":"Functions","title":"PortfolioAnalytics.es","text":"es(R::TSFrame, p::Number=0.95; method::String=\"historical\")\n\nCalculates Expected Shortfall (Conditional Value at Risk) from asset returns. Output is a NamedArray.\n\nArguments:\n\nR::TSFrame: column(s) of TSFrame object of asset returns\np::Number=0.95: confidence level\nmethod::String=\"historical\": method of Expected Shortfall calculation\n\nExample\n\njulia> ES = es(returns)\n4-element Named Vector{Any}\n95% historical ES  │\n───────────────────┼───────────\nTSLA               │  -0.148766\nNFLX               │ -0.0701279\nMSFT               │  -0.066119\n\nNotes:\n\nAvailable methods: \"historical\" and \"parametric\"\nMonte Carlo method will be implemented as part of the next release\n\n\n\n\n\n","category":"function"},{"location":"functions/","page":"Functions","title":"Functions","text":"portfolio_optimize","category":"page"},{"location":"functions/#PortfolioAnalytics.portfolio_optimize","page":"Functions","title":"PortfolioAnalytics.portfolio_optimize","text":"portfolio_optimize(R::TSFrame, objective::String = \"minumum variance\"; target = Nothing, Rf::Number = 0)\n\nCalculates the optimal Portfolio weights for a given objective and target return.\n\nArguments:\n\nR::TSFrame: columns of TSFrame object of asset returns\nobjective::String = \"minumum variance\": portfolio objective, minimizes the standard deviation for the portfolio. Available objecives; \"minumum variance\" and \"maximum sharpe\"\ntarget = Nothing: target portfolio mean return for a chosen objective. It allows to move accross the efficient frontier\nRf::Number = 0: risk-free rate, used with maximum sharpe\n\nExample\n\njulia> opt1 = portfolio_optimize(returns, \"minumum variance\")\njulia> opt_weights = opt1.pweights\n3-element Named Vector{Float64}\nOptimal Weights  │\n─────────────────┼───────\nTSLA             │   -0.0\nNFLX             │ 0.4438\nMSFT             │ 0.5562\n\n\n# plotting efficient frontier and decision space\njulia> opt1.plt\n\nOptimize minumum-variance portfolio with a minumum return target of 4%\n\njulia> opt2 = portfolio_optimize(returns, \"minumum variance\", target = 0.04)\n\n# optimal portfolio weights for a chosen objective and target return\njulia> opt2.pweights\n3-element Named Vector{Float64}\nOptimal Weights  │\n─────────────────┼───────\nTSLA             │ 0.5142\nNFLX             │    0.0\nMSFT             │ 0.4858\n\nOptimization of maximum sharpe portfolio\n\njulia> opt3 = portfolio_optimize(returns, \"maximum sharpe\")\njulia> opt3.pweights\n3-element Named Vector{Float64}\nOptimal Weights  │\n─────────────────┼─────\nTSLA             │ -0.0\nNFLX             │  0.0\nMSFT             │  1.0\n\njulia> opt3.plt\n\nOptimization of maximum sharpe portfolio with target return of at least 4%\n\njulia> opt4 = portfolio_optimize(returns, \"maximum sharpe\", target = 0.04)\njulia> opt4.pweights\n3-element Named Vector{Float64}\nOptimal Weights  │\n─────────────────┼───────\nTSLA             │ 0.5142\nNFLX             │   -0.0\nMSFT             │ 0.4858\n\nOutput:\n\nNamed Tuple\n\n1, preturn : portfolio mean return\n2, prisk: portfolio standard deviation\n3, psharpe: portfolio sharpe ratio\n4, pweights: optimal portfolio weights for chosen objective and defined target\n5, plt: plot of the efficient frontier and decision space\n6, pm: list of expected returns per each solution\n7, po: list of objective values per portfolio. If the objective is minimum-variance, then standard deviations of each optimal portfolio. If the objective is set to the maximum-sharpe, then the Sharpe Ratios of each portfolio.\n8, pw: list of weights per each solution\n\n\n\n\n\n","category":"function"},{"location":"functions/#Example","page":"Functions","title":"Example","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"using JuMP # hide\nusing Ipopt # hide\nusing Statistics # hide\nusing TSFrames # hide\nusing NamedArrays # hide\n\nusing JuMP # hide\nusing Ipopt # hide\nusing MultiObjectiveAlgorithms # hide\nusing Plots # hide\nusing StatsPlots # hide\n\nfunction portfolio_optimize(R::TSFrame, objective::String = \"minumum variance\"; target = Nothing, Rf::Number = 0) # hide\n\n    colnames = names(R) # used only for naming array # hide\n    R = Matrix(R) # hide\n\n    μ = vec(Statistics.mean(R; dims = 1)) # hide\n    Q = Statistics.cov(R) # hide\n\n    model = Model(() -> MultiObjectiveAlgorithms.Optimizer(Ipopt.Optimizer)) # hide\n    set_silent(model) # hide\n    set_optimizer_attribute(model, MultiObjectiveAlgorithms.Algorithm(), MultiObjectiveAlgorithms.EpsilonConstraint()) # hide\n    set_optimizer_attribute(model, MultiObjectiveAlgorithms.SolutionLimit(), 25) # hide\n\n    @variable(model, 0 <= w[1:size(R, 2)] <= 1) # hide\n    @constraint(model, sum(w) == 1) # hide\n    @expression(model, variance, w' * Q * w) # hide\n    @expression(model, expected_return, w' * μ) # hide\n     \n    if objective == \"minumum variance\" # hide\n        # We want to minimize variance and maximize expected return, but we must pick # hide\n        # a single objective sense `Min`, and negate any `Max` objectives: # hide\n        @objective(model, Min, [variance, -expected_return]) # hide\n        if target != Nothing # hide\n            @constraint(model, expected_return >= target) # hide\n        end # hide\n\n    elseif objective == \"maximum sharpe\" # hide\n        @variable(model, sharpe) # hide\n        @NLconstraint(model, sharpe <= expected_return / sqrt(variance))  # hide\n        \n        @objective(model, Max, [expected_return, sharpe]) # hide\n        if target != Nothing # hide\n            @constraint(model, expected_return >= target) # or # hide\n        end # hide\n    else # hide\n        throw(ArgumentError(\"one of the available objective must be chosen\")) # hide\n    end # hide\n\n    \n    optimize!(model) # hide\n    \n    weights = round.(value.(w), digits = 4) # hide\n    portreturn = round(weights' * μ, digits = 4) # hide\n    portrisk = round(sqrt(weights' * Q * weights), digits = 4) # hide\n    portsharpe = round(((weights' * μ) - Rf) / portrisk, digits = 4) # hide\n    weights = NamedArray(weights, colnames, \"Optimal Weights\") # hide\n\n    pm = [value(expected_return; result = i) for i in 1:result_count(model)] # hide\n    pw = [value.(w; result = i) for i in 1:result_count(model)] # hide\n\n    if objective == \"minumum variance\" # hide\n        po = sqrt.([value(variance; result = i) for i in 1:result_count(model)]) # hide\n        plt_objective = Plots.scatter( # hide\n            po, # hide\n            pm*100; # hide\n            xlabel = \"StdDev\", # hide\n            ylabel = \"Return (%)\", # hide\n            label = \"\", # hide\n            markersize = 5, # hide\n            legend = :bottomright, # hide\n            ) # hide\n    \n        decision_space = StatsPlots.groupedbar( # hide\n            vcat([value.(w; result = i)'*100 for i in 1:result_count(model)]...); # hide\n            bar_position = :stack, # hide\n            label = reshape(colnames,1,length(colnames)), # hide\n            xlim = (0.5,25.5), # hide\n            xlabel = \"Portfolio #\", # hide\n            ylabel = \"Weight (%)\", # hide\n            title = \"\", # hide\n        ) # hide\n    \n        plt = Plots.plot(plt_objective, decision_space; layout = (2, 1)) # hide\n    end # hide\n\n    if objective == \"maximum sharpe\" # hide\n            po = [value(sharpe; result = i) for i in 1:result_count(model)] # hide\n            plt_objective = Plots.scatter( # hide\n            po, # hide\n            pm*100; # hide\n            xlabel = \"Sharpe\", # hide\n            ylabel = \"Return (%)\", # hide\n            label = \"\", # hide\n            markersize = 5, # hide\n            legend = :bottomright, # hide\n        ) # hide\n\n        decision_space = StatsPlots.groupedbar( # hide\n            vcat([value.(w; result = i)'*100 for i in 1:result_count(model)]...); # hide\n            bar_position = :stack, # hide\n            label = reshape(colnames,1,length(colnames)), # hide\n            xlim = (0.5,25.5), # hide\n            xlabel = \"Portfolio #\", # hide\n            ylabel = \"Weight (%)\", # hide\n            title = \"\", # hide\n        ) # hide\n\n        plt = Plots.plot(plt_objective, decision_space; layout = (2, 1)) # hide\n    end # hide\n\n    return (preturn = portreturn, prisk = portrisk, psharpe = portsharpe, pweights = weights, plt = plt, pm = pm, po = po, pw = pw) # hide\n\nend # hide\n\nbond = [0.06276629, 0.03958098, 0.08456482,0.02759821,0.09584956,0.06363253,0.02874502,0.02707264,0.08776449,0.02950032]\nstock = [0.1759782,0.20386651,0.21993588,0.3090001,0.17365969,0.10465274,0.07888138,0.13220847,0.28409742,0.14343067]\n\nR = TSFrame([bond stock], colnames  = [:bond, :stock])","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"Minumum variance portfolio.","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"opt = portfolio_optimize(R, \"minumum variance\")\nopt.pweights","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"Minumum variance portfolio with 10% target return.","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"opt1 = portfolio_optimize(R, \"minumum variance\", target = 0.1)\nopt1.plt","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"Maximum Sharpe portfolio with 15% target return.","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"opt2 = portfolio_optimize(R, \"maximum sharpe\", target = 0.15)\nopt2.plt","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"using Plots\n# plotting optimal weights for maximum sharpe portfolio with 15% return target\nbar(names(opt2.pweights), opt2.pweights, labels = false)","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"cumulative_return","category":"page"},{"location":"functions/#PortfolioAnalytics.cumulative_return","page":"Functions","title":"PortfolioAnalytics.cumulative_return","text":"cumulative_return(R::TSFrame; geometric::Bool=true, verbose=false)\n\nCalculates the cumulative asset returns.\n\nArguments:\n\nR::TSFrame: column(s) of TSFrame object of asset returns\ngeometric::Bool=true: if true, calculates geometric returns\nverbose=false: if true, returns a TSFrame object of cumulaitve asset returns for data history\n\nExample\n\njulia> cumulative_return(returns)\n3-element Named Vector{Float64}\nCumulative Return  │\n───────────────────┼─────────\nTSLA               │ 0.497577\nNFLX               │ 0.114123\nMSFT               │ 0.512094\n\njulia> cumulative_return(returns, verbose=true)\n12×3 TSFrame with Date Index\n Index       TSLA      NFLX      MSFT    \n Date        Float64   Float64   Float64 \n─────────────────────────────────────────\n 2021-01-31  1.12452   0.984576  1.04289\n 2021-02-28  0.957232  0.996523  1.04478\n 2021-03-31  0.946518  0.964733  1.06002\n 2021-04-30  1.00536   0.949587  1.1338\n 2021-05-31  0.885979  0.929873  1.12256\n 2021-06-30  0.963183  0.976846  1.21797\n 2021-07-31  0.973812  0.957169  1.28095\n 2021-08-31  1.0426    1.05263   1.35725\n 2021-09-30  1.09893   1.12873   1.26751\n 2021-10-31  1.57865   1.27663   1.49096\n 2021-11-30  1.62223   1.1871    1.48633\n 2021-12-31  1.49758   1.11412   1.51209\n\n julia> cumulative_return(returns, geometric=false)\n3-element Named Vector{Float64}\nCumulative Return  │\n───────────────────┼─────────\nTSLA               │ 0.518126\nNFLX               │ 0.130176\nMSFT               │ 0.439646\n\n\n\n\n\n","category":"function"},{"location":"functions/","page":"Functions","title":"Functions","text":"drawdowns","category":"page"},{"location":"functions/#PortfolioAnalytics.drawdowns","page":"Functions","title":"PortfolioAnalytics.drawdowns","text":"drawdowns(R::TSFrame; geometric::Bool=true, max_drawdown::Bool=false)\n\nCalculates the drawdowns of asset or portfolio returns. Output is a TSFrame object of drawdowns. \n\nArguments:\n\nR::TSFrame: column(s) of TSFrame object of asset returns\ngeometric::Bool=true: if true, calculates drawdowns from the geometric returns\nmax_drawdown::Bool=false: if true, returns maximum drawdown for asset(s) or a portfolio\n\nExample\n\njulia> drawdowns(returns)\n12×3 TSFrame with Date Index\n Index       TSLA        NFLX        MSFT        \n Date        Float64     Float64     Float64     \n─────────────────────────────────────────────────\n 2021-01-31   0.0         0.0         0.0\n 2021-02-28  -0.148766    0.0         0.0\n 2021-03-31  -0.158293   -0.0319013   0.0\n 2021-04-30  -0.10597    -0.0471003   0.0\n 2021-05-31  -0.212128   -0.0668832  -0.00991355\n 2021-06-30  -0.143473   -0.0197458   0.0\n 2021-07-31  -0.134021   -0.0394915   0.0\n 2021-08-31  -0.0728517   0.0         0.0\n 2021-09-30  -0.0227591   0.0        -0.066119\n 2021-10-31   0.0         0.0         0.0\n 2021-11-30   0.0        -0.0701279  -0.00310596\n 2021-12-31  -0.0768384  -0.127291    0.0\n\njulia> drawdowns(returns, geometric=false)\n12×3 TSFrame with Date Index\n Index       TSLA        NFLX         MSFT        \n Date        Float64     Float64      Float64     \n──────────────────────────────────────────────────\n 2021-01-31   0.0        -0.0154236    0.0\n 2021-02-28  -0.132292   -0.00328963   0.0\n 2021-03-31  -0.142245   -0.0351909    0.0\n 2021-04-30  -0.0869655  -0.0508908    0.0\n 2021-05-31  -0.192558   -0.0716515   -0.00878166\n 2021-06-30  -0.115068   -0.0211354    0.0\n 2021-07-31  -0.105255   -0.0412789    0.0\n 2021-08-31  -0.0424401   0.0          0.0\n 2021-09-30   0.0         0.0         -0.0502712\n 2021-10-31   0.0         0.0          0.0\n 2021-11-30   0.0        -0.0555787   -0.00217898\n 2021-12-31  -0.0481756  -0.104299     0.0\n\njulia> drawdowns(returns,  max_drawdown=true)\n3-element Named Vector{Float64}\nMaximum Drawdown  │\n──────────────────┼──────────\nTSLA              │ -0.212128\nNFLX              │ -0.127291\nMSFT              │ -0.066119\n\n\njulia> drawdowns(returns, geometric=false, max_drawdown=true)\n3-element Named Vector{Float64}\nMaximum Drawdown  │\n──────────────────┼───────────\nTSLA              │  -0.192558\nNFLX              │  -0.104299\nMSFT              │ -0.0502712\n\n\n\n\n\n","category":"function"},{"location":"tutorials/#Tutorials","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Except for the code examples and equations, this tutorial's content is generated by Microsoft Bing Chat and modified for clarity.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Throughout this tutorial, we will use the monthly stock prices of Tesla, Netflix, and Microsoft from Dec 2020 through Dec 2021.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"using PortfolioAnalytics\nusing Dates\nusing TSFrames\n\ndates = Date(2020, 12, 31):Month(1):Date(2021, 12, 31);\nTSLA = [235.22,264.51,225.16,222.64,236.48,208.40,226.56,229.06,245.24,258.49,371.33,381.58,352.26];\nNFLX = [540.73,532.39,538.85,521.66,513.47,502.81,528.21,517.57,569.19,610.34,690.31,641.90,602.44];\nMSFT = [222.42,231.96,232.38,235.77,252.18,249.68,270.90,284.91,301.88,281.92,331.62,330.59,336.32];\n\nprices_ts = TSFrame([TSLA NFLX MSFT], dates, colnames=[:TSLA, :NFLX, :MSFT])","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"13×3 TSFrame with Date Index\n Index       TSLA     NFLX     MSFT    \n Date        Float64  Float64  Float64 \n───────────────────────────────────────\n 2020-12-31   235.22   540.73   222.42 \n 2021-01-31   264.51   532.39   231.96 \n 2021-02-28   225.16   538.85   232.38 \n 2021-03-31   222.64   521.66   235.77 \n 2021-04-30   236.48   513.47   252.18 \n 2021-05-31   208.4    502.81   249.68 \n 2021-06-30   226.56   528.21   270.9  \n 2021-07-31   229.06   517.57   284.91 \n 2021-08-31   245.24   569.19   301.88 \n 2021-09-30   258.49   610.34   281.92 \n 2021-10-31   371.33   690.31   331.62\n 2021-11-30   381.58   641.9    330.59\n 2021-12-31   352.26   602.44   336.32","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"weights = [0.4, 0.4, 0.2]","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"using Plots # hide\nplot(prices_ts, size = (600, 420))\ntitle!(\"Stock prices\")\nxlabel!(\"Date\")\nylabel!(\"Price\")","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"warning: Warning\nPortfolioAnalytics encourages you to \"Know Your Data\". Some functions may not work in presence of missing and NA values.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"tip: Tip\nThere is no dropmissing function for a TSFrame object. However, you can convert your data to DataFrame, drop missing values, and convert it back to a TSFrame object.","category":"page"},{"location":"tutorials/#Investment-returns","page":"Tutorials","title":"Investment returns","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"An investment return is the change in value of an invested vehicle over time. It can be positive (profit) or negative (loss). The total  return includes any additional payments such as dividends, coupon payments etc. and price change, while the nominal return only includes price change. ","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"In this tutorial, we will use nominal return.","category":"page"},{"location":"tutorials/#Simple-return","page":"Tutorials","title":"Simple return","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Return = fracP_tP_t-1 - 1","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"function asset_return(price::TSFrame, period::Int=1; method::String=\"simple\") # hide\n\n    if period <= 0 # hide\n        throw(ArgumentError(\"period must be a positive int\")) # hide\n    end # hide\n\n    if method == \"simple\" # hide\n        return TSFrames.pctchange(price, period)[(period+1):end] # hide\n    elseif method == \"log\" # hide\n        returns = log.(price.coredata[:,2:end] ./ TSFrames.lag(price, period).coredata[:,2:end]) # hide\n        ts = TSFrame(returns, TSFrames.index(price))[(period+1):end] # hide\n        return ts # hide\n    else # hide\n        throw(ArgumentError(\"one of the available method must be chosen\")) # hide\n    end # hide\n\nend # hide\n\nreturns = asset_return(prices_ts)","category":"page"},{"location":"tutorials/#Log-return","page":"Tutorials","title":"Log return","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"A log return is a way of calculating the rate of return on an investment using natural logarithms. It is sometimes preferred over simple percentage returns because it has advantages like infinite support and time-additivity. You can calculate the log return by specifying the method argument.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Return = LNfracP_tP_t-1","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"asset_return(prices_ts, method = \"log\")","category":"page"},{"location":"tutorials/#Portfolio-return","page":"Tutorials","title":"Portfolio return","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"A portfolio return refers to how much an investment portfolio gains or loses in a given period. It depends on the expected return and weight of each holding in the portfolio and any dividends or fees involved.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"To calculate your portfolio return, you need to know the returns and weights of each asset type. Then, you can use this formula:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"R_p t=1 = W_A1t=1*R_A1t=1 + W_A2t=1*R_A2t=1 + W_ANt=1*R_ANt=1","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"R_p t=2 = W_A1t=2*R_A1t=2 + W_A2t=2*R_A2t=2 + W_ANt=2*R_ANt=2","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"R_p t=N = W_A1t=N*R_A1t=N + W_A2t=N*R_A2t=N + W_ANt=N*R_ANt=N","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Where:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"R_p t is the portfolio return at period t.\nR is the return of an asset at periods 1, 2 and so on.\nW is the weight of an asset in a portfolio at periods 1, 2 and so on.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Note that portfolio_return( ) function assumes:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"the same weight for the holding period (W is the same at t=1 through t=N).","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"function portfolio_return(price::TSFrame, weights::Vector{<:Number}; period::Int=1, method::String=\"simple\", colname::String=\"PORT\") # hide\n\n    if period <= 0 # hide\n        throw(ArgumentError(\"period must be a positive int\")) # hide\n    end # hide\n    \n    if method == \"simple\" # hide\n        preturns = Matrix(asset_return(price, period, method=method)) * weights # hide\n        ts = TSFrame(preturns, TSFrames.index(price)[(period+1):end]) # hide\n        TSFrames.rename!(ts, [colname]) # hide\n        return ts # hide\n    elseif method == \"log\" # hide\n        preturns = Matrix(asset_return(price, period, method=method)) * weights # hide\n        ts = TSFrame(preturns, TSFrames.index(price)[(period+1):end]) # hide\n        TSFrames.rename!(ts, [colname]) # hide\n        return ts # hide\n    else # hide\n        throw(ArgumentError(\"one of the available method must be chosen\")) # hide\n    end # hide\n\nend # hide\n\npreturns = portfolio_return(prices_ts, weights)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Like the asset_return( ) function, you can choose the method of return calculation using the method argument.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"portfolio_return(prices_ts, weights, method = \"log\")","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"It's possible to overwrite the default column name for the portfolio return column using the colname argument. To calculate the investment returns for a higher than one period, set a positive integer value for the period argument. ","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"portfolio_return(prices_ts, weights, period = 3, method = \"log\", colname = \"PRETURN\")","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"tip: Tip\nYou can join TSFrame objects with the join( ) function from the TSFrames package.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"all_returns = TSFrames.join(returns, preturns)","category":"page"},{"location":"tutorials/#Cumulative-return","page":"Tutorials","title":"Cumulative return","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Cumulative return is a measure of how much an investment has gained or lost over time, regardless of the time period involved. It is calculated as a percentage of your original investment. For example, if you invested $1000 in a stock and it is now worth $1200, your cumulative return would be 20% ($200 / $1000).","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Cumulative return can help you evaluate the overall performance of your investment over its entire history.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"using NamedArrays # hide\nfunction cumulative_return(R::TSFrame; geometric::Bool=true, verbose=false) # hide\n\n    colnames = names(R) # hide\n    idx = TSFrames.index(R) # hide\n\n    R = Matrix(R) # hide\n\n    if any(ismissing.(R)) # hide\n        @warn(\"missing's detected: function may not work in presence of missing's\") # hide\n    end # hide\n\n    if geometric == true # hide\n        R1 = R + ones(size(R)) # hide\n        Rprod = last.(cumprod.(Vector{Float64}.(filter.(!ismissing, eachcol(R1))))) # hide\n        if verbose == false # hide\n            creturn = Rprod .- 1 # hide\n            return NamedArray(creturn, colnames, \"Cumulative Return\") # hide\n        else # hide\n            creturn = cumprod(R1, dims=1) # hide\n            ts = TSFrame(creturn, idx) # hide\n            TSFrames.rename!(ts, colnames) # hide\n            return ts # hide\n        end # hide\n    else # hide\n        if verbose == false # hide\n            creturn = sum.(skipmissing.(eachcol(R))) # hide\n            return NamedArray(creturn, colnames, \"Cumulative Return\") # hide\n        else # hide\n            creturn = cumsum(R, dims=1) + ones(size(R)) # hide\n            ts = TSFrame(creturn, idx) # hide\n            TSFrames.rename!(ts, colnames) # hide\n            return ts # hide\n        end # hide\n\n    end # hide\n\n\nend # hide\n\ncumulative_return(returns)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"By setting verbose to true you can obtain the historical cumulative return of $1 investment. This is very useful if you would like to see how much the value of investment changes over time.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"cumulative_return(returns, verbose=true)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"using Plots # hide\ncreturns = cumulative_return(returns, verbose=true)\nplot(creturns, size = (600, 420))\ntitle!(\"Cumulative asset returns\")\nxlabel!(\"Date\")\nylabel!(\"Cumulative Return\")","category":"page"},{"location":"tutorials/#Average-returns-and-risk","page":"Tutorials","title":"Average returns and risk","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"You can use the mean_return( ) function to calculate the average asset returns over time. Function returns geometric mean by default.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"using Statistics # hide\nusing NamedArrays # hide\n\nfunction mean_return(R::TSFrame; geometric::Bool=true) # hide\n    colnames = names(R) # hide\n    R = Matrix(R) # hide\n    if geometric == false # hide\n        mreturn = Statistics.mean.(eachcol(R)) # hide\n    else  # hide\n        R1 = R + ones(size(R)) # hide\n        Rprod = cumprod(R1, dims=1)[end, :] # hide\n        mreturn = (Rprod .^ (1/size(R)[1])) .- 1 # hide\n    end # hide\n\n    meanReturn = NamedArray(mreturn, colnames, \"μ\") # hide\n    return meanReturn # hide\nend # hide\n\nmean_return(returns)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"To calculate the simple mean, set the geometric parameter to false.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"mu = frac1n sum_i=1^n x_i","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"mean_return(returns, geometric=false)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"To calculate the standard deviation of asset returns of some period, you can use the stddev( ) function.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"sigma = sqrtfrac1n sum_i=1^n (x_i - mu)^2","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"function stddev(R::TSFrame) # hide\n    sddev = Statistics.std.(eachcol(Matrix(R))) # hide\n    colnames = names(R)  # hide\n    standev = NamedArray(sddev, colnames, \"σ\") # hide\n    return standev # hide\nend # hide\n\nstddev(returns)","category":"page"},{"location":"tutorials/#Comparing-returns-and-risk","page":"Tutorials","title":"Comparing returns and risk","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Annualizing is converting a rate of return for a period other than one year into an equivalent annual rate. It helps to compare different investments with different time horizons. For example, if you invest $1000 in a stock that pays 5% interest every six months, your annualized return is (1+0.05)^2 - 1 = 10.25%. This means you would earn 10.25% interest on your investment if you held it for one year.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Annualizing risk measures is similar to annualizing returns but depends on the risk measure used. For example, the standard deviation is a common measure of volatility that can be annualized by multiplying it by the square root of the number of periods per year. However, some risk measures, such as Value at Risk (VaR) or Expected Shortfall (ES), cannot be annualized by simple multiplication because they depend on the distribution of returns.","category":"page"},{"location":"tutorials/#Returns","page":"Tutorials","title":"Returns","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Annual return: total return earned over one calendar year.\nAnnualized return: yearly rate of return inferred from any time period.\nAverage return: total return realized over a longer period, spread evenly over the (shorter) periods.\nCumulative (compounding) return: A return that includes the compounded results of reinvesting interest, dividends, and capital gains.","category":"page"},{"location":"tutorials/#Annualizing-returns","page":"Tutorials","title":"Annualizing returns","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Annualizing a return means calculating the return if it was compounded over a year. We can annualize the returns by multiplying them by a time component depending on their frequency. For example, if you measure a monthly return, you can multiply it by 12 to get an annualized return. On the other hand, if you measure a quarterly return, you can multiply it by 4.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"From monthly returns: $ Return_{Ann} = Return*12$\nFrom daily returns:  $ Return_{Ann} = Return*252$","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Where:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Return is the return of an asset or portfolio we want to annualize.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"As we use monthly returns in our example, we need to multiply them by 12 to annualize.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"returns_annualized  = mean_return(returns) .* 12","category":"page"},{"location":"tutorials/#Annualizing-standard-deviation","page":"Tutorials","title":"Annualizing standard deviation","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"From std of monthly returns: $ Std_{Ann} = Std*\\sqrt{12}$\nFrom std of daily returns:  $ Std_{Ann} = Std*\\sqrt{252}$","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Where:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Std is the standard deviation of returns of an asset or portfolio we want to annualize.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"We can multiply the result of StdDev by sqrt12 to annualize the standard deviation of monthly returns.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"std_annualized  = stddev(returns) .* sqrt(12)","category":"page"},{"location":"tutorials/#Moments","page":"Tutorials","title":"Moments","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Moments are statistical measures that describe certain characteristics of a probability distribution. They are based on the expected values of powers of a random variable. For example, if X is a random variable, then its moments are defined as E(X), E(X²), E(X³), E(X⁴), etc.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"The first moment is equal to the mean of X. The second moment is related to the variance of X. The third moment is associated with the skewness of X. Finally, the fourth moment is related to the kurtosis of X. ","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"You can use the moments( ) function to calculate the statistical moments of asset returns of interest.  Standard deviation is a more widely used risk metric than the variance in portfolio management; therefore moments( ) function uses standard deviation instead of variance.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Mean return is considered as expected return in many applications. It's the sum of a series of returns divided by the count of that series of returns.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"mu = fracsum_i=1^n x_in","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Standard deviation is a statistical measurement in finance that is widely used as an investment's historical volatility.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"sigma = sqrtfracsum_i=1^n (x_i - mu)^2n","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Skewness measures how asymmetric or lopsided a distribution of returns is. Skewness is an important statistical concept because it helps us understand data sets that may not appear \"normal.\" It tells us if returns have been extreme or not. Investors prefer positive skewness, which means more frequent positive returns than negative ones.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"skewness = fracsum_i=1^n (x_i - mu)^3n  sigma^3","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Kurtosis measures how peaked or flat the distribution of returns is. It tells you how often extreme returns occur. Investors generally consider high kurtosis a sign of higher risk because it means more frequent extreme returns (positive or negative) than normal. This is called kurtosis risk. When the excess kurtosis is around 0, or the kurtosis equals about 3, the tails' kurtosis level is similar to the normal distribution. ","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"In the moments( ) function, kurtosis refers to excess kurtosis, which is kurtosis − 3.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"kurtosis = fracsum_i=1^n (x_i - mu)^4n  sigma^4","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"using Distributions # hide\n\nfunction moments(R::TSFrame) # hide\n    \n    Mean = Statistics.mean.(eachcol(Matrix(R))) # hide\n    StdDev = Statistics.std.(eachcol(Matrix(R))) # hide\n    skew = Distributions.skewness.(eachcol(Matrix{Float64}(Matrix(R)))) # hide\n    kurt = Distributions.kurtosis.(eachcol(Matrix{Float64}(Matrix(R)))) # hide\n\n    colnames = names(R) # hide\n    return NamedArray([Mean StdDev skew kurt], (colnames, [\"Mean\", \"Std\", \"Skewness\", \"Kurtosis\"]), (\"Tickers\", \"Moments\")) # hide\nend # hide\n\nmoments(returns)","category":"page"},{"location":"tutorials/#Sharpe-Ratio","page":"Tutorials","title":"Sharpe Ratio","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"The Sharpe ratio is a way to measure how well an investment performs relative to its risk. It compares an investment's returns with a benchmark (such as a risk-free asset) and adjusts for its volatility. The higher the ratio, the better the investment in terms of risk-adjusted returns.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"A positive Sharpe ratio means that the investment has outperformed the risk-free rate. Conversely, a negative Sharpe ratio indicates that the investment has underperformed the risk-free rate.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Sharpe space Ratio = fracR_p space  space R_fsigma_p","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Where; R_p is a portfolio's average return over some period.\nsigma_p is the standard deviation for the same period.\nR_f is the risk-free rate.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"function sharpe(R::TSFrame, Rf::Number=0) # hide\n    meanReturn = mean.(eachcol(Matrix(R))) # hide\n    StdDev = std.(eachcol(Matrix(R))) # hide\n    sharpe = (meanReturn .- Rf) ./ StdDev # hide\n\n    colnames = names(R) # hide\n\n    return NamedArray(sharpe, colnames, \"Sharpe Ratio (Rf=$Rf)\")  # hide\n    \nend # hide\n\nsharpe(returns)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Based on Jan through Dec 2021, we'd obtain the best return by buying Microsoft stocks after adjusting for the risk. ","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Sharpe Ratios are equal to the effective return divided by the standard deviation. Similar to annualizing standard deviation, daily, weekly, or monthly Sharpe Ratios are annualized by multiplying by the square root of the higher frequency period. ","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"sharpe_annualized  = sharpe(returns) .* sqrt(12)","category":"page"},{"location":"tutorials/#Value-at-Risk","page":"Tutorials","title":"Value at Risk","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"VaR is a statistical technique that gives the probability of losing more than a given amount that could happen in an investment portfolio over a specified period. It is usually expressed as a percentage or a dollar amount indicating how much money is at risk over a given period. For example, if an investment has a 5% VaR of $10 million for one day, there is a 5% chance that it will lose more than $10 million in one day.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"There are different methods to calculate VaR, such as historical, variance-covariance, also known as parametric, and Monte Carlo.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"In PortfolioAnalytics.jl, Value at Risk is calculated using the value_at_risk( ) function. By default, it calculates the VaR of asset returns based on the historical simulation method at 95% and expresses it as a percentage.","category":"page"},{"location":"tutorials/#Methods-for-using-calculating-VaR","page":"Tutorials","title":"Methods for using calculating VaR","text":"","category":"section"},{"location":"tutorials/#.-Historical-method","page":"Tutorials","title":"1. Historical method","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"The historical simulation does not assume a particular distribution of asset returns. Instead, it involves taking market data for a certain period (e.g., 250 days) and calculating the percentage change over some period (e.g., daily). The VaR is then calculated as a percentile of these daily percentage changes (returns).","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"function value_at_risk(R::TSFrame, p::Number=0.95; method::String=\"historical\") # hide\n\n    alpha = 1 - p # hide # hide\n\n    if method == \"historical\" # hide\n        VAR = Distributions.quantile.(eachcol(Matrix(R)), alpha) # hide\n    elseif method == \"parametric\" # hide\n        VAR = mean.(eachcol(Matrix(R))) - (std.(eachcol(Matrix(R))) .* Distributions.quantile(Normal(), p))  # hide\n    else # hide\n        throw(ArgumentError(\"one of the available method must be chosen\")) # hide\n    end # hide\n\n    colnames = names(R) # used only for naming array # hide\n    conf = Int(100*p) # used only for naming array  # hide\n    \n    return NamedArray(VAR, colnames, \"$conf% $method VaR\") # hide\n\nend # hide\n\n\nvalue_at_risk(returns)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"The output tells us that there is a 5% chance that Tesla stock will lose more than 13.23% in a month.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"We also can specify the confidence level.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"value_at_risk(returns, 0.90)","category":"page"},{"location":"tutorials/#.-Parametric-VaR","page":"Tutorials","title":"2. Parametric VaR","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Parametric VaR, also known as the variance-covariance method, is a method that uses two main inputs: the mean and standard deviation. It assumes that the assets (or portfolio)'s returns are normally distributed. The calculated standard deviation is used to derive a standard normal z score to size up the position with a confidence level (according to a pre-determined table).","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"To calculate the parametric VaR, we need to specify it using the method argument.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"value_at_risk(returns, method = \"parametric\")","category":"page"},{"location":"tutorials/#.-Monte-Carlo-Method","page":"Tutorials","title":"3. Monte Carlo Method","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"The Monte Carlo method is a technique of numerical integration that can be used to estimate the value at risk (VaR). It simulates many possible scenarios by changing multiple variables and produces probability distributions of risk.","category":"page"},{"location":"tutorials/#Expected-Shortfall-(CVaR)","page":"Tutorials","title":"Expected Shortfall (CVaR)","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Value-at-risk (VaR) is a risk measure that quantifies the maximum loss of a portfolio at a given confidence level and time horizon. For example, if a bank’s 10-day 99% VaR is 20%, there is considered to be only a 1% chance that losses will exceed 20% in 10 days.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Expected Shortfall (ES), also known as the Conditional Value at Risk (CVaR), is a risk measure that quantifies the average loss of a portfolio beyond the VaR level. For example, if the expected shortfall at a 99% confidence level is 30%, it means that the average loss of the portfolio is 30%  when the loss is greater than or equal to 20% (VaR).","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"The main difference between VaR and ES is that VaR only considers losses up to a certain threshold, while ES considers losses beyond that threshold. This means that ES captures more information about the tail risk of a portfolio than VaR does. ES is also considered more coherent and subadditive than VaR, which satisfies some desirable properties for a risk measure.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"function es(R::TSFrame, p::Number=0.95; method::String=\"historical\") # hide\n    \n    valueatrisk = Vector(value_at_risk(R, p, method = method)) # hide\n    idx = Matrix(R) .< valueatrisk' # hide\n    counts = sum.(eachcol(idx)) # hide\n\n    es = [] # hide\n    for (index, col) in enumerate(eachcol(Matrix(R))) # hide\n        \n        exsfall = sum(col[col.<valueatrisk[index]]) / counts[index] # hide\n        push!(es, exsfall) # hide\n    \n    end # hide\n\n    colnames = names(R) # used only for naming array # hide\n    conf = Int(100*p) # used only for naming array # hide\n\n    return NamedArray(es, colnames, \"$conf% $method ES\") # hide\n\nend # hide\n\nes(returns)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Similar to the value_at_risk( ) function, we can specify the confidence level and method of the calculation in the es( ) function. ","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"es(returns, 0.80, method = \"parametric\")","category":"page"},{"location":"tutorials/#Maximum-Drawdown","page":"Tutorials","title":"Maximum Drawdown","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Drawdown is a measure of how much the value of an asset or portfolio drops from its peak before it recovers back to its peak. It is calculated as a percentage between the peak and the trough. For example, if your account balance was $10,000 at its peak and then dropped to $8,000 at its lowest point, your drawdown would be 20% ($2,000 / $10,000).","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Maximum drawdown (MDD) is a measure of how much an investment has lost from its highest peak value to its lowest trough value. It is an indicator of downside risk, with large MDDs suggesting that the investment is volatile and prone to losing value.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"MDD can help you compare different investments or trading strategies based on their risk and performance. A lower MDD means a lower risk of losing money and a higher chance of recovering losses. A higher MDD means a higher risk of losing money and a lower chance of recovering losses.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"function drawdowns(R::TSFrame; geometric::Bool=true, max_drawdown::Bool=false) # hide\n\n    colnames = names(R) # hide\n    idx = TSFrames.index(R) # hide\n\n    R = Matrix(R) # hide\n\n    if geometric == true # hide\n        R1 = R + ones(size(R)) # hide\n        Rprod = cumprod(R1, dims = 1) # hide\n        maxCumulativeReturns = accumulate(max, Rprod, dims = 1) # hide\n        ddowns = (Rprod ./ maxCumulativeReturns) .- 1 # hide\n\n    else # hide\n        cumulativeSum = cumsum(R, dims = 1) # hide\n        R1 = cumulativeSum + ones(size(R)) # hide\n        first_row = ones(1, size(R)[2]) # hide\n        maxCumulativeReturns = accumulate(max, vcat(first_row, R1), dims = 1)[2:end, :] # hide\n        ddowns = (R1 ./ maxCumulativeReturns) .- 1 # hide\n    \n    end # hide\n\n    if max_drawdown == true # hide\n        max_ddowns = minimum(ddowns, dims=1) # hide\n        return NamedArray(vec(max_ddowns), colnames, \"Maximum Drawdown\") # hide\n    else # hide\n        ts = TSFrame(ddowns, idx) # hide\n        TSFrames.rename!(ts, colnames) # hide\n        return ts # hide\n    end # hide\n    \n    \nend # hide\n\ndrawdowns(returns)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"drawdowns( ) function calculates drawdowns from geometric returns by default. To calculate drawdowns from simple returns, set the geometric=false.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"drawdowns(returns, geometric=false)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"You can calculate maximum drawdown by setting max_drawdown argument to true.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"drawdowns(returns, max_drawdown=true)","category":"page"},{"location":"tutorials/#Portfolio-Optimization","page":"Tutorials","title":"Portfolio Optimization","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Portfolio optimization is selecting the best portfolio from a set of possible portfolios according to some objective. The objective usually involves maximizing expected return and minimizing risk. ","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Many portfolio optimization methods use different criteria and techniques to find the optimal portfolio. Some of the common methods are:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Mean-variance (MV): This method uses expected return and variance as measures of reward and risk and tries to find the portfolio with the highest return for a given level of risk or the lowest risk for a given level of return.\nSharpe Ratio: This method tries to find the portfolio with the highest return for a given level of Sharpe Ratio. \nValue-at-Risk (VaR): This method uses a probability threshold to measure risk and tries to find the portfolio with the highest return while keeping its loss below a certain level with a specified confidence level.\nExpected Shortfall: This method uses expected loss beyond VaR as a measure of risk and tries to find the portfolio with the highest return while minimizing its potential extreme loss.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"The portfolio_optimize( ) function is used to find the optimal weights of a portfolio for a chosen objective and target return. The set of optimal portfolios forms a curve called the efficient frontier.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"At the moment it is possible to find mean-variance and maximum-sharpe portfolios. Optimization using Value at Risk (VaR) and Expected Shortfall (ES) will be implemented as part of the next releases.","category":"page"},{"location":"tutorials/#Risk-of-a-portfolio","page":"Tutorials","title":"Risk of a portfolio","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Investing is risky: individual assets will go up or down\nExpected return is a random variable\nReturns spread around the mean are measured by the variance σ and is a common measure of volatility\nVariance of an individual asset varies: some have more or less spread around the mean\nVariance of the portfolio is not simply weighted variances of the underlying assets\nBecause returns of assets are correlated, it becomes complex\nThe correlation between asset 1 and asset 2 is denoted by P_12 and tells us to which extend assets move together\nThe portfolio variance takes into account the individual assets' variance (σ_1^2σ_2^2etc), the weights of the assets in portfolio (w_1 w_2), as well as their correlation to each other","category":"page"},{"location":"tutorials/#Calculating-two-asset-portfolio-variance","page":"Tutorials","title":"Calculating two-asset portfolio variance","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"sigma_p^2 = w_1^2σ_1^2 + w_2^2σ_2^2 + 2w_1w_2p_12σ_1σ_2","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"p_12σ_1σ_2 is called the covariance between asset 1 and 2\nThe covariance can also be written as σ_12\nThe equation then becomes:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"sigma_p^2 = w_1^2σ_1^2 + w_2^2σ_2^2 + 2w_1w_2σ_12","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"This can be re-written in matrix notation, which we can generalize the concept","category":"page"},{"location":"tutorials/#Two-asset-portfolio-variance-matrix-form","page":"Tutorials","title":"Two-asset portfolio variance matrix-form","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"sigma_p^2 = beginbmatrix w_1  w_2 endbmatrix beginbmatrix σ_1^2  σ_12   σ_21  σ_2^2 endbmatrixbeginbmatrix w_1  w_2 endbmatrix","category":"page"},{"location":"tutorials/#Step-by-step-matrix-multiplications-for-two-asset-portfolio-variance","page":"Tutorials","title":"Step-by-step matrix multiplications for two-asset portfolio variance","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"sigma_p^2 = beginbmatrix w_1 * σ_1^2 +  w_2 * σ_21   w_1 * σ_12 +  w_2* σ_2^2endbmatrix beginbmatrix w_1  w_2 endbmatrix","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"sigma_p^2 = (w_1 * σ_1^2 +  w_2 * σ_21) * w_1  +  (w_1 * σ_12 +  w_2* σ_2^2) * w_2","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"where σ_12 = σ_21","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"sigma_p^2 = w_1^2σ_1^2 + w_2^2σ_2^2 + 2w_1w_2σ_12","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"So, it can be extended to any number of assets in the below form:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Portfolio space variance = w * Q * w","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Where;","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"w is the assets' weights in a portfolio\nw is the transpose of w\nQ is the covariance matrix","category":"page"},{"location":"tutorials/#.-Mean-Variance","page":"Tutorials","title":"1. Mean-Variance","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Modern portfolio theory (MPT) states that portfolio variance can be reduced by selecting securities with low or negative correlations in which to invest, such as stocks and bonds.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Mean-variance optimization is a quantitative tool that allows you to allocate your portfolio by considering the trade-off between risk and return. It is based on modern portfolio theory (MPT), a mathematical framework for assembling a portfolio of assets that maximizes expected return for a given level of risk. The optimal portfolio is found by minimizing the variance (or standard deviation) of the portfolio returns for a given expected return or maximizing the expected return for a given variance. ","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Portfolio expected return:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"μ_p =  beginbmatrix w_1  w_2 endbmatrix beginbmatrix μ_1  μ_2 endbmatrix","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Where;","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"μ_1 and μ_2 are the average returns for assets 1 and 2, respctively\n\nw_1 and w_2 are the weights of assets 1 and 2 in a portfolio, respectively.\n","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Portfolio standard deviation:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"sigma_p = sqrtsigma_p^2","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Note that we are solving the problem under the following assumptions:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"We are fully invested. The sum of weights is 1.\nWe can trade any continuum of shares.\nNo short-selling is allowed.\nThere are no transaction costs.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"using JuMP # hide\nusing Ipopt # hide\nusing MultiObjectiveAlgorithms # hide\nusing Plots # hide\nusing StatsPlots # hide\n\nfunction portfolio_optimize(R::TSFrame, objective::String = \"minumum variance\"; target = Nothing, Rf::Number = 0) # hide\n\n    colnames = names(R) # used only for naming array # hide\n    R = Matrix(R) # hide\n\n    μ = vec(Statistics.mean(R; dims = 1)) # hide\n    Q = Statistics.cov(R) # hide\n\n    model = Model(() -> MultiObjectiveAlgorithms.Optimizer(Ipopt.Optimizer)) # hide\n    set_silent(model) # hide\n    set_optimizer_attribute(model, MultiObjectiveAlgorithms.Algorithm(), MultiObjectiveAlgorithms.EpsilonConstraint()) # hide\n    set_optimizer_attribute(model, MultiObjectiveAlgorithms.SolutionLimit(), 25) # hide\n\n    @variable(model, 0 <= w[1:size(R, 2)] <= 1) # hide\n    @constraint(model, sum(w) == 1) # hide\n    @expression(model, variance, w' * Q * w) # hide\n    @expression(model, expected_return, w' * μ) # hide\n     \n    if objective == \"minumum variance\" # hide\n        # We want to minimize variance and maximize expected return, but we must pick # hide\n        # a single objective sense `Min`, and negate any `Max` objectives: # hide\n        @objective(model, Min, [variance, -expected_return]) # hide\n        if target != Nothing # hide\n            @constraint(model, expected_return >= target) # hide\n        end # hide\n\n    elseif objective == \"maximum sharpe\" # hide\n        @variable(model, sharpe) # hide\n        @NLconstraint(model, sharpe <= expected_return / sqrt(variance))  # hide\n        \n        @objective(model, Max, [expected_return, sharpe]) # hide\n        if target != Nothing # hide\n            @constraint(model, expected_return >= target) # or # hide\n        end # hide\n    else # hide\n        throw(ArgumentError(\"one of the available objective must be chosen\")) # hide\n    end # hide\n\n    \n    optimize!(model) # hide\n    \n    weights = round.(value.(w), digits = 4) # hide\n    portreturn = round(weights' * μ, digits = 4) # hide\n    portrisk = round(sqrt(weights' * Q * weights), digits = 4) # hide\n    portsharpe = round(((weights' * μ) - Rf) / portrisk, digits = 4) # hide\n    weights = NamedArray(weights, colnames, \"Optimal Weights\") # hide\n\n    pm = [value(expected_return; result = i) for i in 1:result_count(model)] # hide\n    pw = [value.(w; result = i) for i in 1:result_count(model)] # hide\n\n    if objective == \"minumum variance\" # hide\n        po = sqrt.([value(variance; result = i) for i in 1:result_count(model)]) # hide\n        plt_objective = Plots.scatter( # hide\n            po, # hide\n            pm*100; # hide\n            xlabel = \"StdDev\", # hide\n            ylabel = \"Return (%)\", # hide\n            label = \"\", # hide\n            markersize = 5, # hide\n            legend = :bottomright, # hide\n            ) # hide\n    \n        decision_space = StatsPlots.groupedbar( # hide\n            vcat([value.(w; result = i)'*100 for i in 1:result_count(model)]...); # hide\n            bar_position = :stack, # hide\n            label = reshape(colnames,1,length(colnames)), # hide\n            xlim = (0.5,25.5), # hide\n            xlabel = \"Portfolio #\", # hide\n            ylabel = \"Weight (%)\", # hide\n            title = \"\", # hide\n        ) # hide\n    \n        plt = Plots.plot(plt_objective, decision_space; layout = (2, 1)) # hide\n    end # hide\n\n    if objective == \"maximum sharpe\" # hide\n            po = [value(sharpe; result = i) for i in 1:result_count(model)] # hide\n            plt_objective = Plots.scatter( # hide\n            po, # hide\n            pm*100; # hide\n            xlabel = \"Sharpe\", # hide\n            ylabel = \"Return (%)\", # hide\n            label = \"\", # hide\n            markersize = 5, # hide\n            legend = :bottomright, # hide\n        ) # hide\n\n        decision_space = StatsPlots.groupedbar( # hide\n            vcat([value.(w; result = i)'*100 for i in 1:result_count(model)]...); # hide\n            bar_position = :stack, # hide\n            label = reshape(colnames,1,length(colnames)), # hide\n            xlim = (0.5,25.5), # hide\n            xlabel = \"Portfolio #\", # hide\n            ylabel = \"Weight (%)\", # hide\n            title = \"\", # hide\n        ) # hide\n\n        plt = Plots.plot(plt_objective, decision_space; layout = (2, 1)) # hide\n    end # hide\n\n    return (preturn = portreturn, prisk = portrisk, psharpe = portsharpe, pweights = weights, plt = plt, pm = pm, po = po, pw = pw) # hide\n\nend # hide\n\nopt = portfolio_optimize(returns)\n\nopt.plt","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Expected return for the minumum variance portfolio.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"opt.preturn","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Standard deviation, risk, for the mimumum variance portfolio.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"opt.prisk","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Optimal weights for the mimnumum variance portfolio.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"opt.pweights ","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"So if we have $1000 and buy $440 (44%) Netflix shares and $560 (56%) Microsoft shares, we expect, on average, $25 (2.5%) monthly return and our portfolio to fluctuate $53 (5.3%). $25 (2.5%) monthly expected return is a good deal for a minimum-variance portfolio, but the data we work with in this tutorial is only from Jan 2021 through Dec 2021. It is one of the good years for the stock market. Be careful about the data you use when making investment decisions!","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Investors do not always want to choose a portfolio with the lowest risk. Instead, they may want to accept a higher risk for a higher return. The best way to achieve this is to define a target return by setting a value to the target parameter in the portfolio_optimize( ) function. It will automatically eliminate the portfolios with lower-than-defined target returns.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"For example, we want optimal portfolios with monthly expected returns higher than 3.5%.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"opt = portfolio_optimize(returns, target = 0.035)\nopt.plt","category":"page"},{"location":"tutorials/#.-Sharpe-Ratio","page":"Tutorials","title":"2. Sharpe Ratio","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Portfolio optimization with the Sharpe ratio is a method of finding an optimal portfolio with the highest excess return per unit of risk. The optimal portfolio is found by maximizing the expected return for a given Sharpe ratio.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Portfolio expected return:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"μ_p =  beginbmatrix w_1  w_2 endbmatrix beginbmatrix μ_1  μ_2 endbmatrix","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Where;","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"μ_1 and μ_2 are the average returns for assets 1 and 2, respectively\nw_1 and w_2 are the weights of assets 1 and 2 in a portfolio, respectively.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Portfolio Sharpe Ratio:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Sharpe space Ratio_p =  fracμ_p - rfσ_p","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Where;","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"μ_p is the portfolio expected return\nrf is the risk-free rate\nσ_p is the portfolio standard deviation","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Let's optimize the portfolio and plot the efficient frontier, a set of optimal portfolios that offer the highest expected return for a given level of Sharpe Ratio.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"opt2 = portfolio_optimize(returns, \"maximum sharpe\")\nopt2.plt","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Similar to mean-variance portfolios, we may consider portfolios with higher returns. Let's define a monthly target return of 4% and plot the efficient frontier.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"opt2 = portfolio_optimize(returns, \"maximum sharpe\", target = 0.04)\nopt2.plt","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"It's possible to extract the risk, defined as standard deviation, Sharpe ratio, and weights of each optimal portfolio in efficient frontier. This is particularly useful if you would like to make custom plots.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"List of expected returns per portfolio.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"opt2.pm","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"List of objective values per portfolio. If the objective is minimum-variance, then standard deviations of each optimal portfolio. If the objective is set to the maximum-sharpe, then the Sharpe Ratios of each portfolio.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"opt2.po","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"List of weights corresponding to each portfolio on the efficient frontier.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"opt2.pw","category":"page"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/#Development-version","page":"Installation","title":"Development version","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"julia> using Pkg\njulia> Pkg.add(url=\"https://github.com/doganmehmet/PortfolioAnalytics.jl\")","category":"page"},{"location":"installation/#Stable-version","page":"Installation","title":"Stable version","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"julia> using Pkg\njulia> Pkg.add(\"PortfolioAnalytics\")","category":"page"},{"location":"installation/#Update-currently-installed-version","page":"Installation","title":"Update currently installed version","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"julia> using Pkg\njulia> Pkg.update(\"PortfolioAnalytics\")","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Caution: The package is under heavy development, and the dev version may significantly differ from the current stable version.","category":"page"},{"location":"#PortfolioAnalytics.jl","page":"Introduction","title":"PortfolioAnalytics.jl","text":"","category":"section"},{"location":"#Tool-for-Quantitative-Portfolio-Analytics","page":"Introduction","title":"Tool for Quantitative Portfolio Analytics","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The PortfolioAnalytics.jl aims to provide users with functionality for performing quantitative portfolio analytics. The package is under heavy development, and new functionalities will be added as part of ongoing releases.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The following functions are available in stable version:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"asset_return( )\nportfolio_return( )\nsharpe( )\nvalue_at_risk( )\nportfolio_optimize( )\nmean_returns( )\nstddev( )\nmoments( )\nes( )\ncumulative_return( )\ndrawdowns( )","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This package generally requires return (rather than price) data. Almost all functions will work with any periodicity, from annual, monthly, daily, to even minutes and seconds, either regular or irregular.","category":"page"},{"location":"#Getting-started","page":"Introduction","title":"Getting started","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The best place to get started with PortfolioAnalytics is the Tutorials section, where you can find the demonstration of functions' use.\nGo to the Installation guide to learn how you can install PortfolioAnalytics.\nRead the Functions section to learn more about functions' parameters and default arguments.","category":"page"},{"location":"#Contributions-are-most-welcome","page":"Introduction","title":"Contributions are most welcome","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"We greatly value contributions of any kind. Contributions could include but are not limited to documentation improvements, bug reports, new or improved code, scientific and technical code reviews, infrastructure improvements, mailing lists, chat participation, community help/building, education, and outreach.","category":"page"},{"location":"#Bug-reports-and-feature-requests","page":"Introduction","title":"Bug reports and feature requests","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Please report any issues via the GitHub issue tracker. All kinds of issues are welcome and encouraged; this includes bug reports, documentation typos, feature requests, etc.","category":"page"},{"location":"#Acknowledgement","page":"Introduction","title":"Acknowledgement","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The package is inspired by PerformanceAnalytics and PortfolioAnalytics packages in R and pyfolio in Python.","category":"page"}]
}
