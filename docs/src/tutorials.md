# Tutorials
Except for the code examples and equations, this tutorial's content is generated by *Microsoft Bing Chat* and modified for clarity.

Throughout this tutorial, we will use the monthly stock prices of Tesla, Netflix, and Microsoft from Dec 2020 through Dec 2021.
```@example half-loop; continued = true
using PortfolioAnalytics
using Dates
using TSFrames

dates = Date(2020, 12, 31):Month(1):Date(2021, 12, 31);
TSLA = [235.22,264.51,225.16,222.64,236.48,208.40,226.56,229.06,245.24,258.49,371.33,381.58,352.26];
NFLX = [540.73,532.39,538.85,521.66,513.47,502.81,528.21,517.57,569.19,610.34,690.31,641.90,602.44];
MSFT = [222.42,231.96,232.38,235.77,252.18,249.68,270.90,284.91,301.88,281.92,331.62,330.59,336.32];

prices_ts = TSFrame([TSLA NFLX MSFT], dates, colnames=[:TSLA, :NFLX, :MSFT])
```
```julia
13×3 TSFrame with Date Index
 Index       TSLA     NFLX     MSFT    
 Date        Float64  Float64  Float64 
───────────────────────────────────────
 2020-12-31   235.22   540.73   222.42 
 2021-01-31   264.51   532.39   231.96 
 2021-02-28   225.16   538.85   232.38 
 2021-03-31   222.64   521.66   235.77 
 2021-04-30   236.48   513.47   252.18 
 2021-05-31   208.4    502.81   249.68 
 2021-06-30   226.56   528.21   270.9  
 2021-07-31   229.06   517.57   284.91 
 2021-08-31   245.24   569.19   301.88 
 2021-09-30   258.49   610.34   281.92 
 2021-10-31   371.33   690.31   331.62
 2021-11-30   381.58   641.9    330.59
 2021-12-31   352.26   602.44   336.32
```
```@example half-loop
weights = [0.4, 0.4, 0.2]
```

```@example half-loop
using Plots # hide
plot(prices_ts, size = (600, 420))
title!("Stock prices")
xlabel!("Date")
ylabel!("Price")
savefig("s-plot.svg"); nothing # hide
```

![](s-plot.svg)

!!! warning
    **PortfolioAnalytics** encourages you to **"Know Your Data"**. Some functions may not work in presence of `missing` and `NA` values.

!!! tip
    There is no `dropmissing` function for a `TSFrame` object. However, you can convert your data to `DataFrame`, drop `missing` values, and convert it back to a `TSFrame` object.

## Investment Returns
An investment return is the change in value of an invested vehicle over time. It can be positive (profit) or negative (loss). The total  return includes any additional payments such as dividends, coupon payments etc. and price change, while the nominal return only includes price change. 

In this tutorial, we will use nominal return.

#### Simple return
```math
Return = \frac{P_t}{P_{t-1}} - 1
```

```@example half-loop
function Return(price::TSFrame, period::Int=1; method::String="simple") # hide

    if period <= 0 # hide
        throw(ArgumentError("period must be a positive int")) # hide
    end # hide

    if method == "simple" # hide
        return TSFrames.pctchange(price, period)[(period+1):end] # hide
    elseif method == "log" # hide
        returns = log.(price.coredata[:,2:end] ./ TSFrames.lag(price, period).coredata[:,2:end]) # hide
        ts = TSFrame(returns, TSFrames.index(price))[(period+1):end] # hide
        return ts # hide
    else # hide
        throw(ArgumentError("one of the available method must be chosen")) # hide
    end # hide

end # hide

returns = Return(prices_ts)
```

#### Log return
A *log return* is a way of calculating the rate of return on an investment using natural logarithms. It is sometimes preferred over simple percentage returns because it has advantages like infinite support and time-additivity. You can calculate the log return by specifying the **method** argument.
```math
Return = LN\frac{P_t}{P_{t-1}}
```
```@example half-loop
Return(prices_ts, method = "log")
```

## Portfolio Return
A portfolio return refers to how much an investment portfolio gains or loses in a given period. It depends on the expected return and weight of each holding in the portfolio and any dividends or fees involved.

To calculate your portfolio return, you need to know the returns and weights of each asset type. Then, you can use this formula:

```math
R_{p, t=1} = W_{A1,t=1}*R_{A1,t=1} + W_{A2,t=1}*R_{A2,t=1} + W_{AN,t=1}*R_{AN,t=1}
```

```math
R_{p, t=2} = W_{A1,t=2}*R_{A1,t=2} + W_{A2,t=2}*R_{A2,t=2} + W_{AN,t=2}*R_{AN,t=2}
```

```math
R_{p, t=N} = W_{A1,t=N}*R_{A1,t=N} + W_{A2,t=N}*R_{A2,t=N} + W_{AN,t=N}*R_{AN,t=N}
```
Where:
* ``R_{p, t}`` is the portfolio return at period `t`.
* `R` is the return of an asset at periods `1`, `2` and so on.
* `W` is the weight of an asset in a portfolio at periods `1`, `2` and so on.

Note that *portfolio_return( )* function assumes:
* the same weight for the holding period (`W` is the same at `t=1` through `t=N`).


```@example half-loop
function portfolio_return(price::TSFrame, weights::Vector{<:Number}; period::Int=1, method::String="simple", colname::String="PORT") # hide

    if period <= 0 # hide
        throw(ArgumentError("period must be a positive int")) # hide
    end # hide
    
    if method == "simple" # hide
        preturns = Matrix(Return(price, period, method=method)) * weights # hide
        ts = TSFrame(preturns, TSFrames.index(price)[(period+1):end]) # hide
        TSFrames.rename!(ts, [colname]) # hide
        return ts # hide
    elseif method == "log" # hide
        preturns = Matrix(Return(price, period, method=method)) * weights # hide
        ts = TSFrame(preturns, TSFrames.index(price)[(period+1):end]) # hide
        TSFrames.rename!(ts, [colname]) # hide
        return ts # hide
    else # hide
        throw(ArgumentError("one of the available method must be chosen")) # hide
    end # hide

end # hide

preturns = portfolio_return(prices_ts, weights)
```

Like the *Return( )* function, you can choose the method of return calculation using the **method** argument.
```@example half-loop
portfolio_return(prices_ts, weights, method = "log")
```

It's possible to overwrite the default column name for the portfolio return column using the **colname** argument. To calculate the investment returns for a higher than one period, set a positive integer value for the **period** argument. 
```@example half-loop
portfolio_return(prices_ts, weights, period = 3, method = "log", colname = "PRETURN")
```

!!! tip
    You can join *TSFrame* objects with the **join( )** function from the *TSFrames* package.
```@example half-loop
all_returns = TSFrames.join(returns, preturns)
```


## Average returns and risk
You can use the **mean_return( )** function to calculate the average asset returns of some period.

```math
\mu = \frac{1}{n} \sum_{i=1}^n x_i
```

```@example half-loop
using Statistics # hide
using NamedArrays # hide

function mean_return(R::TSFrame; geometric::Bool=false) # hide
    colnames = names(R) # hide
    R = Matrix(R) # hide
    if geometric == false # hide
        mreturn = Statistics.mean.(eachcol(R)) # hide
    else  # hide
        R1 = R + ones(size(R)) # hide
        Rprod = cumprod(R1, dims=1)[end, :] # hide
        mreturn = (Rprod .^ (1/size(R)[1])) .- 1 # hide
    end # hide

    meanReturn = NamedArray(mreturn, colnames, "μ") # hide
    return meanReturn # hide
end # hide

mean_return(all_returns)
```

To calculate the *geometric mean*, set the **geometric** parameter to `true`.
```@example half-loop
mean_return(all_returns, geometric=true)
```

To calculate the standard deviation of asset returns of some period, you can use the **stddev( )** function.
```math
\sigma = \sqrt{\frac{1}{n} \sum_{i=1}^n (x_i - \mu)^2}
```


```@example half-loop
function stddev(R::TSFrame) # hide
    sddev = Statistics.std.(eachcol(Matrix(R))) # hide
    colnames = names(R)  # hide
    standev = NamedArray(sddev, colnames, "σ") # hide
    return standev # hide
end # hide

stddev(all_returns)
```


## Comparing returns and risk
Annualizing is converting a rate of return for a period other than one year into an equivalent annual rate. It helps to compare different investments with different time horizons. For example, if you invest \$1000 in a stock that pays 5% interest every six months, your annualized return is `(1+0.05)^2 - 1 = 10.25%`. This means you would earn 10.25% interest on your investment if you held it for one year.

Annualizing risk measures is similar to annualizing returns but depends on the risk measure used. For example, the standard deviation is a common measure of volatility that can be annualized by multiplying it by the square root of the number of periods per year. However, some risk measures, such as Value at Risk (VaR) or Expected Shortfall (ES), cannot be annualized by simple multiplication because they depend on the distribution of returns.

###### Returns
1. **Annual return**: total return earned over one calendar year.
2. **Annualized return**: yearly *rate of return* inferred from any time period.
3. **Average return**: total return realized over a longer period, spread evenly over the (shorter) periods.
4. **Cumulative (compounding) return**: A return that includes the compounded results of reinvesting interest, dividends, and capital gains.

###### Annualizing returns
Annualizing a return means calculating the return if it was compounded over a year. We can annualize the returns by multiplying them by a time component depending on their frequency. For example, if you measure a monthly return, you can multiply it by 12 to get an annualized return. On the other hand, if you measure a quarterly return, you can multiply it by 4.

* **From monthly returns**: $ Return_{Ann} = Return*12$
* **From daily returns**:  $ Return_{Ann} = Return*252$

Where:
* ``Return`` is the **`return`** of an asset or portfolio we want to annualize.

As we use monthly returns in our example, we need to multiply them by *12* to annualize.
```@example half-loop
returns_annualized  = mean_return(all_returns) .* 12
```

###### Annualizing standard deviation
* **From std of monthly returns**: $ Std_{Ann} = Std*\sqrt{12}$
* **From std of daily returns**:  $ Std_{Ann} = Std*\sqrt{252}$

Where:
* ``Std`` is the **`standard deviation`** of returns of an asset or portfolio we want to annualize.

We can multiply the result of StdDev by ``\sqrt{12}`` to annualize the standard deviation of monthly returns.
```@example half-loop
std_annualized  = stddev(all_returns) .* sqrt(12)
```

## Moments
Moments are statistical measures that describe certain characteristics of a probability distribution. They are based on the expected values of powers of a random variable. For example, if X is a random variable, then its moments are defined as E(X), E(X²), E(X³), E(X⁴), etc.

The first moment is equal to the **mean** of X. The second moment is related to the **variance** of X. The third moment is associated with the **skewness** of X. Finally, the fourth moment is related to the **kurtosis** of X. 

You can use the **moments( )** function to calculate the statistical moments of asset returns of interest.  **Standard deviation** is a more widely used risk metric than the variance in portfolio management; therefore *moments( )* function uses standard deviation instead of variance.

*Mean return* is considered as *expected return* in many applications. It's the sum of a series of returns divided by the count of that series of returns.

```math
\mu = \frac{\sum_{i=1}^n x_i}{n}
```

*Standard deviation* is a statistical measurement in finance that is widely used as an investment's historical volatility.

```math
\sigma = \sqrt{\frac{\sum_{i=1}^n (x_i - \mu)^2}{n}}
```

Skewness measures how asymmetric or lopsided a distribution of returns is. Skewness is an important statistical concept because it helps us understand data sets that may not appear "normal." It tells us if returns have been extreme or not. Investors prefer positive skewness, which means more frequent positive returns than negative ones.

```math
skewness = \frac{\sum_{i=1}^n (x_i - \mu)^3}{n . \sigma^3}
```
Kurtosis measures how peaked or flat the distribution of returns is. It tells you how often extreme returns occur. Investors generally consider high kurtosis a sign of higher risk because it means more frequent extreme returns (positive or negative) than normal. This is called kurtosis risk. When the excess kurtosis is around 0, or the kurtosis equals about 3, the tails' kurtosis level is similar to the normal distribution. 

In the *moments( )* function, *kurtosis* refers to *excess kurtosis*, which is `kurtosis − 3`.


```math
kurtosis = \frac{\sum_{i=1}^n (x_i - \mu)^4}{n . \sigma^4}
```

```@example half-loop
using Distributions # hide

function moments(R::TSFrame) # hide
    
    Mean = Statistics.mean.(eachcol(Matrix(R))) # hide
    StdDev = Statistics.std.(eachcol(Matrix(R))) # hide
    skew = Distributions.skewness.(eachcol(Matrix{Float64}(Matrix(R)))) # hide
    kurt = Distributions.kurtosis.(eachcol(Matrix{Float64}(Matrix(R)))) # hide

    colnames = names(R) # hide
    return NamedArray([Mean StdDev skew kurt], (colnames, ["Mean", "Std", "Skewness", "Kurtosis"]), ("Tickers", "Moments")) # hide
end # hide

moments(all_returns)
```



## Sharpe Ratio
The Sharpe ratio is a way to measure how well an investment performs relative to its risk. It compares an investment's returns with a benchmark (such as a risk-free asset) and adjusts for its volatility. The higher the ratio, the better the investment in terms of risk-adjusted returns.

A positive Sharpe ratio means that the investment has outperformed the risk-free rate. Conversely, a negative Sharpe ratio indicates that the investment has underperformed the risk-free rate.

```math
Sharpe \space\ Ratio = \frac{R_p \space\ – \space\ R_f}{\sigma_p}
```
Where;
$R_p$ is a portfolio's `average return` over some period.\
$\sigma_p$ is the `standard deviation` for the same period.\
$R_f$ is the `risk-free rate.`

```@example half-loop
function sharpe(R::TSFrame, Rf::Number=0) # hide
    meanReturn = mean.(eachcol(Matrix(R))) # hide
    StdDev = std.(eachcol(Matrix(R))) # hide
    sharpe = (meanReturn .- Rf) ./ StdDev # hide

    colnames = names(R) # hide

    return NamedArray(sharpe, colnames, "Sharpe Ratio (Rf=$Rf)")  # hide
    
end # hide

sharpe(all_returns)
```
Based on Jan through Dec 2021, we'd obtain the best return by buying Microsoft stocks after adjusting for the risk. 

Sharpe Ratios are equal to the effective return divided by the standard deviation. Similar to annualizing standard deviation, daily, weekly, or monthly Sharpe Ratios are annualized by multiplying by the square root of the higher frequency period. 

```@example half-loop
sharpe_annualized  = sharpe(all_returns) .* sqrt(12)
```


## Value at Risk
*VaR* is a statistical technique that gives the probability of losing more than a given amount that could happen in an investment portfolio over a specified period. It is usually expressed as a percentage or a dollar amount indicating how much money is at risk over a given period. For example, if an investment has a 5% VaR of \$10 million for one day, there is a 5% chance that it will lose more than \$10 million in one day.

There are different methods to calculate VaR, such as *historical*, *variance-covariance*, also known as *parametric*, and *Monte Carlo*.

In PortfolioAnalytics.jl, *Value at Risk* is calculated using the **VaR( )** function. By default, it calculates the *VaR* of asset returns based on the *historical simulation* method at *95%* and expresses it as a *percentage*.

### Methods for using calculating VaR
#### 1. Historical method
The historical simulation does not assume a particular distribution of asset returns. Instead, it involves taking market data for a certain period (e.g., 250 days) and calculating the percentage change over some period (e.g., daily). The *VaR* is then calculated as a percentile of these daily percentage changes (returns).

```@example half-loop
function VaR(R::TSFrame, p::Number=0.95; method::String="historical") # hide

    alpha = 1 - p # hide # hide

    if method == "historical" # hide
        VAR = Distributions.quantile.(eachcol(Matrix(R)), alpha) # hide
    elseif method == "parametric" # hide
        VAR = mean.(eachcol(Matrix(R))) - (std.(eachcol(Matrix(R))) .* Distributions.quantile(Normal(), p))  # hide
    else # hide
        throw(ArgumentError("one of the available method must be chosen")) # hide
    end # hide

    colnames = names(R) # used only for naming array # hide
    conf = Int(100*p) # used only for naming array  # hide
    
    return NamedArray(VAR, colnames, "$conf% $method VaR") # hide

end # hide


VaR(all_returns)
```
The output tells us that there is a `5%` chance that our portfolio (*PORT*) will lose more than `5.59%` in a month.


We also can specify the confidence level.
```@example half-loop
VaR(all_returns, 0.90)
```


#### 2. Parametric VaR
*Parametric VaR*, also known as the *variance-covariance* method, is a method that uses two main inputs: the *mean* and *standard deviation*. It assumes that the assets (or portfolio)'s returns are normally distributed. The calculated standard deviation is used to derive a *standard normal z score* to size up the position with a confidence level (according to a pre-determined table).

To calculate the *parametric VaR*, we need to specify it using the **method** argument.
```@example half-loop
VaR(all_returns, method = "parametric")
```

#### 3. Monte Carlo Method
The *Monte Carlo* method is a technique of numerical integration that can be used to estimate the value at risk (VaR). It simulates many possible scenarios by changing multiple variables and produces probability distributions of risk.


## Expected Shortfall (CVaR)
*Value-at-risk (VaR)* is a risk measure that quantifies the maximum loss of a portfolio at a given confidence level and time horizon. For example, if a bank’s 10-day 99% VaR is 20%, there is considered to be only a 1% chance that losses will exceed 20% in 10 days.

**Expected Shortfall (ES)**, also known as the **Conditional Value at Risk (CVaR)**, is a risk measure that quantifies the average loss of a portfolio beyond the VaR level. For example, if the expected shortfall at a 99% confidence level is 30%, it means that the average loss of the portfolio is 30%  when the loss is greater than or equal to 20% (VaR).

The main difference between *VaR* and *ES* is that *VaR* only considers losses up to a certain threshold, while *ES* considers losses beyond that threshold. This means that *ES* captures more information about the tail risk of a portfolio than VaR does. *ES* is also considered more coherent and subadditive than VaR, which satisfies some desirable properties for a risk measure.

```@example half-loop
function es(R::TSFrame, p::Number=0.95; method::String="historical") # hide
    
    valueatrisk = Vector(VaR(R, p, method = method)) # hide
    idx = Matrix(R) .< valueatrisk' # hide
    counts = sum.(eachcol(idx)) # hide

    es = [] # hide
    for (index, col) in enumerate(eachcol(Matrix(R))) # hide
        
        exsfall = sum(col[col.<valueatrisk[index]]) / counts[index] # hide
        push!(es, exsfall) # hide
    
    end # hide

    colnames = names(R) # used only for naming array # hide
    conf = Int(100*p) # used only for naming array # hide

    return NamedArray(es, colnames, "$conf% $method ES") # hide

end # hide

es(all_returns)
```

Similar to the *VaR( )* function, we can specify the **confidence level** and **method** of the calculation in the *es( )* function. 
```@example half-loop
es(all_returns, 0.80, method = "parametric")
```

## Portfolio Optimization

Portfolio optimization is selecting the best portfolio from a set of possible portfolios according to some objective. The objective usually involves maximizing expected return and minimizing risk. 

Many portfolio optimization methods use different criteria and techniques to find the optimal portfolio. Some of the common methods are:
* *Mean-variance (MV)*: This method uses expected return and variance as measures of reward and risk and tries to find the portfolio with the highest return for a given level of risk or the lowest risk for a given level of return.
* *Sharpe Ratio*: This method tries to find the portfolio with the highest return for a given level of Sharpe Ratio. 
* *Value-at-Risk (VaR)*: This method uses a probability threshold to measure risk and tries to find the portfolio with the highest return while keeping its loss below a certain level with a specified confidence level.
* *Expected Shortfall*: This method uses expected loss beyond VaR as a measure of risk and tries to find the portfolio with the highest return while minimizing its potential extreme loss.

The **portfolio_optimize( )** function is used to find the optimal weights of a portfolio for a chosen objective and target return. The set of optimal portfolios forms a curve called the **efficient frontier**.

At the moment it is possible to find *mean-variance* and *maximum-sharpe* portfolios. Optimization using *Value at Risk (VaR)* and *Expected Shortfall (ES)* will be implemented as part of the next releases.

#### Risk of a portfolio
- Investing is risky: individual assets will go up or down
- Expected return is a **random variable**
- Returns spread around the mean are measured by the variance **σ** and is a common measure of volatility
- Variance of an individual asset varies: some have more or less spread around the mean
- Variance of the portfolio is **not** simply weighted variances of the underlying assets
- Because returns of assets are correlated, it becomes complex
- The **correlation** between asset 1 and asset 2 is denoted by $P_{1,2}$ and tells us to which extend assets move together
- The portfolio variance takes into account the individual assets' variance $(σ_{1}^2,σ_{2}^2,etc.)$, the **weights** of the assets in portfolio $(w_{1}, w_{2})$, as well as their **correlation** to each other


#### Calculating two-asset portfolio variance
```math
\sigma_{p}^2 = w_{1}^2σ_{1}^2 + w_{2}^2σ_{2}^2 + 2w_{1}w_{2}p_{1,2}σ_{1}σ_{2}
```
    
- ``p_{1,2}σ_{1}σ_{2}`` is called the covariance between asset 1 and 2
- The covariance can also be written as $σ_{1,2}$
- The equation then becomes:

```math
\sigma_{p}^2 = w_{1}^2σ_{1}^2 + w_{2}^2σ_{2}^2 + 2w_{1}w_{2}σ_{1,2}
```

- This can be re-written in matrix notation, which we can generalize the concept

##### Two-asset portfolio variance matrix-form
```math
\sigma_{p}^2 = \begin{bmatrix} w_{1} & w_{2} \end{bmatrix} \begin{bmatrix} σ_{1}^2 & σ_{1,2}  \\ σ_{2,1} & σ_{2}^2 \end{bmatrix}\begin{bmatrix} w_{1} \\ w_{2} \end{bmatrix}
```

##### Step-by-step matrix multiplications for two-asset portfolio variance
```math
\sigma_{p}^2 = \begin{bmatrix} w_{1} * σ_{1}^2 +  w_{2} * σ_{2,1}  & w_{1} * σ_{1,2} +  w_{2}* σ_{2}^2\end{bmatrix} \begin{bmatrix} w_{1} \\ w_{2} \end{bmatrix}
```

```math
\sigma_{p}^2 = (w_{1} * σ_{1}^2 +  w_{2} * σ_{2,1}) * w_{1}  +  (w_{1} * σ_{1,2} +  w_{2}* σ_{2}^2) * w_{2}
```

where $σ_{1,2} = σ_{2,1}$

```math
\sigma_{p}^2 = w_{1}^2σ_{1}^2 + w_{2}^2σ_{2}^2 + 2w_{1}w_{2}σ_{1,2}
```

So, it can be extended to any number of assets in the below form:
```math
Portfolio \space\ variance = w' * Q * w
```
Where;
- ``w`` is the assets' weights in a portfolio
- ``w'`` is the transpose of ``w``
- ``Q`` is the covariance matrix



### 1. Mean-Variance
[Modern portfolio theory (MPT)](https://www.investopedia.com/terms/m/modernportfoliotheory.asp) states that portfolio variance can be reduced by selecting securities with low or negative correlations in which to invest, such as stocks and bonds.

Mean-variance optimization is a quantitative tool that allows you to allocate your portfolio by considering the trade-off between risk and return. It is based on modern portfolio theory (MPT), a mathematical framework for assembling a portfolio of assets that maximizes expected return for a given level of risk. The optimal portfolio is found by minimizing the variance (or standard deviation) of the portfolio returns for a given expected return or maximizing the expected return for a given variance. 

Portfolio expected return:
```math
μ_{p} =  \begin{bmatrix} w_{1} & w_{2} \end{bmatrix} \begin{bmatrix} μ_{1} \\ μ_{2} \end{bmatrix}
```
Where;
- ``μ_{1}`` and ``μ_{2}`` are the average returns for assets 1 and 2, respctively\
- ``w_{1}`` and ``w_{2}`` are the weights of assets 1 and 2 in a portfolio, respectively.\

Portfolio standard deviation:
```math
\sigma_{p} = \sqrt{\sigma_{p}^2}
```

Note that we are solving the problem under the following assumptions:
1. We are fully invested. The sum of weights is 1.
2. We can trade any continuum of shares.
3. No short-selling is allowed.
4. There are no transaction costs.

```@example half-loop
using JuMP # hide
using Ipopt # hide
using MultiObjectiveAlgorithms # hide
using Plots # hide
using StatsPlots # hide

function portfolio_optimize(R::TSFrame, objective::String = "minumum variance"; target = Nothing, Rf::Number = 0) # hide

    colnames = names(R) # used only for naming array # hide
    R = Matrix(R) # hide

    μ = vec(Statistics.mean(R; dims = 1)) # hide
    Q = Statistics.cov(R) # hide

    model = Model(() -> MultiObjectiveAlgorithms.Optimizer(Ipopt.Optimizer)) # hide
    set_silent(model) # hide
    set_optimizer_attribute(model, MultiObjectiveAlgorithms.Algorithm(), MultiObjectiveAlgorithms.EpsilonConstraint()) # hide
    set_optimizer_attribute(model, MultiObjectiveAlgorithms.SolutionLimit(), 25) # hide

    @variable(model, 0 <= w[1:size(R, 2)] <= 1) # hide
    @constraint(model, sum(w) == 1) # hide
    @expression(model, variance, w' * Q * w) # hide
    @expression(model, expected_return, w' * μ) # hide
     
    if objective == "minumum variance" # hide
        # We want to minimize variance and maximize expected return, but we must pick # hide
        # a single objective sense `Min`, and negate any `Max` objectives: # hide
        @objective(model, Min, [variance, -expected_return]) # hide
        if target != Nothing # hide
            @constraint(model, expected_return >= target) # hide
        end # hide

    elseif objective == "maximum sharpe" # hide
        @variable(model, sharpe) # hide
        @NLconstraint(model, sharpe <= expected_return / sqrt(variance))  # hide
        
        @objective(model, Max, [expected_return, sharpe]) # hide
        if target != Nothing # hide
            @constraint(model, expected_return >= target) # or # hide
        end # hide
    else # hide
        throw(ArgumentError("one of the available objective must be chosen")) # hide
    end # hide

    
    optimize!(model) # hide
    
    weights = round.(value.(w), digits = 4) # hide
    portreturn = round(weights' * μ, digits = 4) # hide
    portrisk = round(sqrt(weights' * Q * weights), digits = 4) # hide
    portsharpe = round(((weights' * μ) - Rf) / portrisk, digits = 4) # hide
    weights = NamedArray(weights, colnames, "Optimal Weights") # hide

    pm = [value(expected_return; result = i) for i in 1:result_count(model)] # hide
    pw = [value.(w; result = i) for i in 1:result_count(model)] # hide

    if objective == "minumum variance" # hide
        po = sqrt.([value(variance; result = i) for i in 1:result_count(model)]) # hide
        plt_objective = Plots.scatter( # hide
            po, # hide
            pm*100; # hide
            xlabel = "StdDev", # hide
            ylabel = "Return (%)", # hide
            label = "", # hide
            markersize = 5, # hide
            legend = :bottomright, # hide
            ) # hide
    
        decision_space = StatsPlots.groupedbar( # hide
            vcat([value.(w; result = i)'*100 for i in 1:result_count(model)]...); # hide
            bar_position = :stack, # hide
            label = reshape(colnames,1,length(colnames)), # hide
            xlim = (0.5,25.5), # hide
            xlabel = "Portfolio #", # hide
            ylabel = "Weight (%)", # hide
            title = "", # hide
        ) # hide
    
        plt = Plots.plot(plt_objective, decision_space; layout = (2, 1)) # hide
    end # hide

    if objective == "maximum sharpe" # hide
            po = [value(sharpe; result = i) for i in 1:result_count(model)] # hide
            plt_objective = Plots.scatter( # hide
            po, # hide
            pm*100; # hide
            xlabel = "Sharpe", # hide
            ylabel = "Return (%)", # hide
            label = "", # hide
            markersize = 5, # hide
            legend = :bottomright, # hide
        ) # hide

        decision_space = StatsPlots.groupedbar( # hide
            vcat([value.(w; result = i)'*100 for i in 1:result_count(model)]...); # hide
            bar_position = :stack, # hide
            label = reshape(colnames,1,length(colnames)), # hide
            xlim = (0.5,25.5), # hide
            xlabel = "Portfolio #", # hide
            ylabel = "Weight (%)", # hide
            title = "", # hide
        ) # hide

        plt = Plots.plot(plt_objective, decision_space; layout = (2, 1)) # hide
    end # hide

    return (preturn = portreturn, prisk = portrisk, psharpe = portsharpe, pweights = weights, plt = plt, pm = pm, po = po, pw = pw) # hide

end # hide

opt = portfolio_optimize(returns)

opt.plt
savefig("o3-plot.svg"); nothing # hide
```
![](o3-plot.svg)

Expected return for the minumum variance portfolio.
```@example half-loop
opt.preturn
```
Standard deviation, risk, for the mimumum variance portfolio.
```@example half-loop
opt.prisk
```
Optimal weights for the mimnumum variance portfolio.
```@example half-loop
opt.pweights 
```

So if we have \$1000 and buy \$440 (44%) Netflix shares and \$560 (56%) Microsoft shares, we expect, on average, \$25 (2.5%) monthly return and our portfolio to fluctuate \$53 (5.3%). \$25 (2.5%) monthly expected return is a good deal for a minimum-variance portfolio, but the data we work with in this tutorial is only from Jan 2021 through Dec 2021. It is one of the good years for the stock market. Be careful about the data you use when making investment decisions!

Investors do not always want to choose a portfolio with the lowest risk. Instead, they may want to accept a higher risk for a higher return. The best way to achieve this is to define a target return by setting a value to the **target** parameter in the **portfolio_optimize( )** function. It will automatically eliminate the portfolios with lower-than-defined target returns.

For example, we want optimal portfolios with monthly expected returns higher than 3.5%.
 ```@example half-loop
opt = portfolio_optimize(returns, target = 0.035)
opt.plt
savefig("o4-plot.svg"); nothing # hide
```
![](o4-plot.svg)

### 2. Sharpe Ratio
Portfolio optimization with the Sharpe ratio is a method of finding an optimal portfolio with the highest excess return per unit of risk. The optimal portfolio is found by maximizing the expected return for a given Sharpe ratio.

Portfolio expected return:
```math
μ_{p} =  \begin{bmatrix} w_{1} & w_{2} \end{bmatrix} \begin{bmatrix} μ_{1} \\ μ_{2} \end{bmatrix}
```
Where;
- ``μ_{1}`` and ``μ_{2}`` are the average returns for assets 1 and 2, respectively
- ``w_{1}`` and ``w_{2}`` are the weights of assets 1 and 2 in a portfolio, respectively.

Portfolio Sharpe Ratio:
```math
Sharpe \space\ Ratio_{p} =  \frac{μ_{p} - rf}{σ_{p}}
```
Where;
- ``μ_{p}`` is the portfolio expected return
- ``rf`` is the risk-free rate
- ``σ_{p}`` is the portfolio standard deviation

Let's optimize the portfolio and plot the efficient frontier, a set of optimal portfolios that offer the highest expected return for a given level of Sharpe Ratio.
```@example half-loop
opt2 = portfolio_optimize(returns, "maximum sharpe")
opt2.plt
savefig("o5-plot.svg"); nothing # hide
```
![](o5-plot.svg)

Similar to *mean-variance* portfolios, we may consider portfolios with higher returns. Let's define a monthly target return of 4% and plot the efficient frontier.
```@example half-loop
opt2 = portfolio_optimize(returns, "maximum sharpe", target = 0.04)
opt2.plt
savefig("o6-plot.svg"); nothing # hide
```
![](o6-plot.svg)

It's possible to extract the *risk*, defined as standard deviation, *Sharpe ratio*, and *weights* of each optimal portfolio in *efficient frontier*. This is particularly useful if you would like to make custom plots.

List of expected returns per portfolio.
```@example half-loop
opt2.pm
```

List of objective values per portfolio. If the objective is *minimum-variance*, then standard deviations of each optimal portfolio. If the objective is set to the *maximum-sharpe*, then the Sharpe Ratios of each portfolio.
```@example half-loop
opt2.po
```

List of weights corresponding to each portfolio on the efficient frontier.
```@example half-loop
opt2.pw
```
